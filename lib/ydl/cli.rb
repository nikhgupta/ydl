require 'thor'

module Ydl
  # Class that deals with the CLI interface.
  #
  class CLI < Thor

    class_option :verbose, type: :boolean, default: false,
      desc: "show verbose output generated by the program"

    def initialize *args
      super

      # ensure that the delegator is ready for a new command
      Ydl.delegator.reset_for_next_command
      # Ydl::Videos.reload!

      # Raise an error unless Ydl has been initialized or the task was not found.
      # FIXME: use dynamic methods, instead!
      subcommand    = args[2][:current_command].name.downcase.to_sym
      safe_commands = [:init, :help]
      available     = [:update, :add, :search, :download]
      return if safe_commands.include? subcommand

      # err out with usage if Ydl has not been initialized
      unless Ydl::HouseKeeper.initialized?
        error! "You must run 'ydl init' first!", true
      end

      # err out with usage if an unknown command was requested
      unless available.include?(subcommand)
        error! "Command with name '#{subcommand}' not found!", true
      end
    end

    desc 'help', "display the help message for Ydl"
    def help tip = true
      print "Available "
      super()
      puts "Tip: You must run `ydl init` before you can run other commands." if tip
    end

    # Initialize Ydl on the user's machine, and update youtube-dl, as well.
    #
    # At the moment, no checks are performed to ensure that Ydl is compatible
    # with the given machine, but in the future, it will be so.
    #
    desc 'init', "initialize youtube-dl and companion on this system."
    method_option :update, type: :boolean, default: true,
      desc: "Whether to update 'youtube-dl' program?"
    def init
      # hire a new housekeeper
      house_keeper, settings = Ydl::HouseKeeper.new, {}

      # greet the owner.
      question = <<-CONTENT.gsub(/^\s{8}/, '')
        Welcome to YDL. The Youtube-DL companion!
        I would love to assist you in your quest, but first, let me ask you:

        Where should I download the videos? (Give me a folder!)
        Note that, this directory will be created, if it does not exist!
        [default: <current-directory>]
      CONTENT

      download_dir = File.expand_path ask(question).strip
      classifier   = "%(extractor)s/%(title)s-%(id)s-%(age_limit)s.%(ext)s"

      # let the owner know, what mischief we are upto :)
      puts "\nAlright! That's it :)\nI will do the initial house-keeping for you."

      # find the path to the youtube-dl program
      begin
        Ydl.delegator.path
      rescue RuntimeError
        question = <<-CONTENT.gsub(/^\s{10}/, '')
          Seems like this is not my brightest day.. :(
          I was unable to find a valid path to the youtube-dl program on your machine.
          Can you tell me where it is located?
        CONTENT
        bin_path = File.expand_path ask(question).strip
      end

      # enough talk! get to work.
      house_keeper.run_setup download_path: download_dir, classifier: classifier, bin_path: bin_path
      house_keeper.upgrade! if options[:update]
    end

    # TODO: and, maybe the companion, itself?
    desc 'update', "update youtube-dl on this system."
    def update
      house_keeper = Ydl::HouseKeeper.new
      house_keeper.upgrade!
    end

    desc 'add [PATH1] [PATH2] [URL]..', "add videos from the given files and supplied urls"
    method_option :piped, type: :boolean, default: false,
      desc: "display progress for all videos separately to enable piping support"
    def add *paths
      urls = []

      # populate the list of urls from files and urls supplied to the command.
      paths.each do |path|
        if File.readable?(path)
          urls |= (File.readlines(path).map(&:strip) rescue [])
        else # elsif path.url?
          urls.push path
        end
      end

      # only download metadata for videos not already in database
      Ydl.debug "Adding #{urls.count} video(s) in the database."
      existing = Ydl::Videos.where_url_in(urls).map(&:url)
      Ydl.debug "Found #{existing.count} existing video(s) in the database." if existing.any?

      progress = ProgressBar.create({
        total: urls.count, starting_at: existing.count,
        title: "Completed", format: "%a | %b>>%i | %c/%C %t"
      }) unless options[:piped] || options[:verbose]

      # insert or update video(s) in the database, and
      # display the progress.
      data = Ydl::Videos.feed_on_multiple(urls - existing, options[:verbose]) do |url, meta|
        if meta
          Ydl.debug "Found metadata for: #{url}" unless progress
        else
          Ydl.warn "Could not found metadata for: #{url}" unless progress
        end
        progress.increment if progress
      end

      # display the statistics
      added     = data.reject{ |url, meta| meta.nil? }.keys
      discarded = urls.count - added.count
      Ydl.debug "Added #{added.count} video(s)."
      Ydl.debug "Discarded #{discarded} video(s)." if discarded > 0
      Ydl.debug "Generated fuzzy-match database.."

      # return the urls which were added to the database
      added | existing
    end

    desc 'search [KEYWORDS]', "search and display videos with the given keywords"
    method_option :eid, type: :string, desc: "return videos matching the given video (extractor) ID"
    method_option :extractor, type: :string, desc: "filter down the matches based on the given extractor"
    method_option :url, type: :string, desc: "return videos matching the given video url"
    method_option :limit, type: :numeric, default: 10,
      desc: "limit the number of matching results returned by this command (default: 10)"
    def search *keywords
      # 1st element: list of songs matching the request
      # 2nd element: fuzzy matching statistics
      matched, stats, query = Ydl::Searcher.new(keywords, options).run

      matched.each do |vid|
        # TODO: convert the following to methods
        status = (vid.completed ? "C" : "P")
        file_path = vid.file_path.gsub(Dir.pwd, "./")
                       .gsub(ENV['HOME'], '~') if vid.completed

        puts "#{"%3d" % vid[:score]} pts : [#{status}] : #{vid.nice_title}"
        puts "        : #{file_path}" if file_path
      end

      message = "Displaying a total of #{matched.count} videos."
      puts "-" * message.length
      puts message
    end

    desc 'download [PATH1] [PATH2] [URL]..', "download and add videos from the given files and supplied urls"
    method_option :piped, type: :boolean, default: false,
      desc: "display progress for all videos separately to enable piping support"
    def download *paths

      # first, add the videos to the database
      # TODO: use url list from the result of this command, instead.
      urls = invoke :add, paths
      downloaded = []

      if urls.count > 0
        existing = Ydl::Videos.completed.where url: urls
        Ydl.debug "Downloading #{urls.count} video(s)."
        Ydl.debug "Found #{existing.count} existing video(s)." if existing.any?
      else
        Ydl.debug "Nothing to download :("
        return
      end

      # Download the pending videos
      Ydl::Videos.pending.where(url: urls).each do |video|
        Ydl.delegator.output = options[:verbose]
        Ydl.debug "Downloading video: #{video.nice_title}"
        Ydl.debug "This may take a while.."
        response = video.download

        if response[:file]
          Ydl.debug "Downloaded to: #{video.file_path}"
          downloaded.push video.url
        end

        if options[:verbose] && response[:error]
          Ydl.warn ":\n"+ response[:output]
        elsif options[:verbose]
          Ydl.debug ":\n" + response[:output]
        elsif response[:error]
          Ydl.warn response[:error]
        end
      end

      discarded = urls.count - downloaded.count
      Ydl.debug "Downloaded #{downloaded.count} video(s)."
      Ydl.debug "Discarded #{discarded} video(s)." if discarded > 0
    end


    default_task :help

    no_tasks {
      private

      def error! message, show_usage = false
        puts "Error Occurred: #{message}\n\n"
        invoke :help, [false] if show_usage
        exit(128)
      end
    }
  end
end

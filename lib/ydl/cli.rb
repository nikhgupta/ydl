require 'thor'

module Ydl
  # Class that deals with the CLI interface.
  #
  class CLI < Thor

    class_option :verbose, type: :boolean, default: false,
      desc: "show verbose output generated by the program"

    def initialize *args
      super

      # ensure that the delegator is ready for a new command
      Ydl.delegator.reset_for_next_command
      # Ydl::Videos::Data.reload!

      # Raise an error unless Ydl has been initialized or the task was not found.
      # FIXME: use dynamic methods, instead!
      subcommand    = args[2][:current_command].name.downcase.to_sym
      safe_commands = [:init, :help]
      available     = [:update, :feed, :search, :download]
      return if safe_commands.include? subcommand

      # err out with usage if Ydl has not been initialized
      unless Ydl::HouseKeeper.initialized?
        error! "You must run 'ydl init' first!", true
      end

      # err out with usage if an unknown command was requested
      unless available.include?(subcommand)
        error! "Command with name '#{subcommand}' not found!", true
      end
    end

    desc 'help', "display the help message for Ydl"
    def help tip = true
      print "Available "
      super()
      puts "Tip: You must run `ydl init` before you can run other commands." if tip
    end

    # Initialize Ydl on the user's machine, and update youtube-dl, as well.
    #
    # At the moment, no checks are performed to ensure that Ydl is compatible
    # with the given machine, but in the future, it will be so.
    #
    desc 'init', "initialize youtube-dl and companion on this system."
    method_option :update, type: :boolean, default: true,
      desc: "Whether to update 'youtube-dl' program?"
    def init
      # hire a new housekeeper
      house_keeper = Ydl::HouseKeeper.new
      settings     = {}

      # greet the owner.
      puts "Welcome to YDL. The Youtube-DL companion!"
      puts "I would love to assist you in your quest, but first, let me ask you:"
      puts

      # which room should I use?
      question  = "Where should I download the videos? (Give me a folder!)\n"
      question += "Note that, this directory will be created, if it does not exist!\n"
      question += "[default: <current-directory>] "
      settings[:download_path]   = File.expand_path ask(question).strip

      # should I bring the party home?
      question  = "Should I, also, download the playlist associated with a video? [no]"
      settings[:allow_playlists] = yes? question

      # oh, yes! I am organized.
      # FIXME: really needed?
      settings[:classifier]      = "%(extractor)s/%(title)s-%(id)s-%(hash)s.%(ext)s"

      puts
      if house_keeper.compatible?
        # let the owner know, what mischief we are upto :)
        puts "Alright! That's it :)"
        puts "I will, now, do the initial house-keeping for you."

        # find the path to the youtube-dl program
        begin
          Ydl.delegator.path
        rescue RuntimeError
          puts "Seems like this is not my brightest day.. :("
          puts "I was unable to find a valid path to the youtube-dl program on your machine."
          question = "Can you tell me where it is located?"
          options[:youtube_dl_path] = File.expand_path(ask question).strip
        end

        # enough talk! get to work.
        house_keeper.run_setup settings
        house_keeper.upgrade! if options[:update]
      else
        # saying goodbyes. :(
        puts "Unfortunately, I am incompatible with your system."
        puts "I am not sure how that happened."
        puts "All I know is that I need to throw myself out."
      end
    end

    # TODO: and, maybe the companion, itself?
    desc 'update', "update youtube-dl on this system."
    def update
      house_keeper = Ydl::HouseKeeper.new
      house_keeper.upgrade!
    end

    desc 'feed [PATH1] [PATH2] [URL]..', "add videos from the given files and supplied urls"
    method_option :piped, type: :boolean, default: false,
      desc: "display progress for all videos separately to enable piping support"
    def feed *paths
      urls, added = [], 0

      # populate the list of urls from files and urls supplied to the command.
      paths.each do |path|
        if File.readable?(path)
          urls |= (File.readlines(path).map(&:strip) rescue [])
        else # elsif path.url?
          urls.push path
        end
      end

      # only download metadata for videos not already in database
      total    = urls.count
      urls     = Ydl::Videos.filter_out_existing_videos(urls)
      existing = total - urls.count

      Ydl.debug "Adding #{total} video(s) in the database."
      Ydl.debug "Found #{existing} existing video(s) in the database." if existing > 0

      progress = ProgressBar.create({
        total: total, starting_at: existing,
        title: "Completed", format: "%a | %b>>%i | %c/%C %t"
      }) unless options[:piped] || options[:verbose]

      # insert or update video(s) in the database, and
      # display the progress.
      Ydl::Videos.iterate_on_metadata_for(urls, options[:verbose]) do |url, meta|
        if meta
          Ydl::Videos::Data.upsert meta
          Ydl.debug "Found metadata for: #{url}" unless progress
          added += 1
        else
          Ydl.warn "Could not found metadata for: #{url}" unless progress
        end
        progress.increment if progress
      end

      # display the statistics
      Ydl.debug "Added #{added} video(s)."
      Ydl.debug "Discarded #{urls.count - added} video(s)." unless urls.count == added

      # re-generate our fuzzy match database.
      Ydl.debug "Generating fuzzy match database.."
      Ydl::FuzzBall.prepare
    end

    desc 'search [KEYWORDS]', "search and display videos with the given keywords"
    method_option :eid, type: :string, desc: "return videos matching the given video (extractor) ID"
    method_option :extractor, type: :string, desc: "filter down the matches based on the given extractor"
    method_option :url, type: :string, desc: "return videos matching the given video url"
    method_option :limit, type: :numeric, default: 10,
      desc: "limit the number of matching results returned by this command (default: 10)"
    def search *keywords
      # 1st element: list of songs matching the request
      # 2nd element: fuzzy matching statistics
      matched, stats = Ydl::Videos.search keywords, options

      matched.each do |vid|
        # TODO: convert the following to methods
        status = (vid.completed ? "C" : "P")
        file_path = vid.file_path.gsub(Dir.pwd, "./")
                       .gsub(ENV['HOME'], '~') if vid.completed

        puts "#{"%3d" % vid[:score]} pts : [#{status}] : #{vid.nice_title}"
        puts "        : #{file_path}" if file_path
      end

      message = "Displaying a total of #{matched.count} videos."
      puts "-" * message.length
      puts message
    end

    desc 'download [PATH1] [PATH2] [URL]..', "download and add videos from the given files and supplied urls"
    method_option :piped, type: :boolean, default: false,
      desc: "display progress for all videos separately to enable piping support"
    def download *paths

      # first, add the videos to the database
      invoke :feed, paths

      urls, downloaded = [], 0

      # populate the list of urls from files and urls supplied to the command.
      paths.each do |path|
        if File.readable?(path)
          urls |= (File.readlines(path).map(&:strip) rescue [])
        else # elsif path.url?
          urls.push path
        end
      end

      # only download metadata for videos not already in database
      total    = urls.count
      urls     = Ydl::Videos.filter_out_existing_videos(urls, completed: 1)
      existing = total - urls.count

      Ydl.debug "Downloading #{total} video(s)."
      Ydl.debug "Found #{existing} existing video(s)." if existing > 0

      # Download the videos so found
      Ydl::Videos::Data.where(url: urls).each do |video|
        Ydl.delegator.output = options[:verbose]
        Ydl.debug "Downloading video: #{video.nice_title}"
        Ydl.debug "This may take a while.."
        response = video.download
        if response.has_key? :file
          Ydl.debug "Downloaded to: #{video.file_path}"
          downloaded += 1
        elsif !options[:verbose] && response[:error]
          Ydl.warn "\n"+response[:output]
        end
      end

      Ydl.debug "Downloaded #{downloaded} video(s)."

    end


    default_task :help

    no_tasks {
      private

      def error! message, show_usage = false
        puts "Error Occurred: #{message}\n\n"
        invoke :help, [false] if show_usage
        exit(128)
      end
    }
  end
end
